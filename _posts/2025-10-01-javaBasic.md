---
layout: post
title: "실전 자바 기본"
---

인프런 <u>김영한의 실전 자바 - 기본편</u>을 보고 정리해보았다.

# 1. 클래스와 데이터
- 클래스: 객체를 생성하기 위한 '틀', '설계도'에 해당된다.
  - 클래스를 사용해 만들어진 실제 메모리를 객체 또는 인스턴스라고 한다.
  
```java
public class Student {
    String name;
    int age;
    int grade;
}
```
> - 멤버 변수(Member Variable): 특정 클래스에 소속된 멤버
- 필드(Field): 데이터 항목을 가리킨다.
➡️ 자바에서 멤버변수, 필드는 같은 뜻이다.


객체가 생성되는 원리

1. 변수 선언
```java
Student student1;
```
Student 타입을 받을 수 있는 변수를 선언한다.

2. 객체 생성
```java
student1 = new Student()// Student 인스턴스 생성
```
메모리에 실제 Student 객체를 생성해 메모리 공간을 확보한다.

3. 참조값 보관
```java
student1 = x001; // Student 인스턴스 참조값 보관
```
객체를 생성하면 자바는 메모리에 이 객체를 접근할 수 있는 참조값(주소)을 반환한다.

- 예시
```java
student1.name="학생1"//1. student1 객체의 name 멤버 변수에 값 대입
x001.name="학생1"//2.변수에 있는 참조값을 통해 실제 객체에 접근, 
//해당 객체의 name 멤버 변수에 값대입
```

- 객체 값 읽을때
```java
//1. 객체 값 읽기
System.out.println("이름:" + student1.name);
//2. 변수에 있는 참조값을 통해 실제 객체에 접근하고, name 멤버 변수에 접근한다.
System.out.println("이름:" + x001.name);
//3. 객체의 멤버 변수의 값을 읽어옴
System.out.println("이름:" + "학생1")
```

---

# 2. 기본형과 참조형
- **기본형(Primitive Type)**: 변수에 사용할 **값**을 직접 넣을 수 있는 데이터 타입
- **참조형(Reference Type)**: 데이터에 접근하기 위한 **참조(주소)**를 저장하는 데이터 타입

> - 객체는 `.`을 통해서 메모리 상에 생성된 객체를 찾아가 사용할 수 있다.
- 배열은 `[]`을 통해서 메모리 상에 생성된 배열을 찾아가 사용할 수 있다.

> `String`
자바에서 String은 클래스이자 참조형이다.
그런데 기본형처럼 문자 값을 바로 대입 할 수 있다.
문자는 자주 다루기 때문에 자바의 편의 기능을 제공해서 가능한 것이다.

1. 계산
기본형은 들어있는 값을 그대로 **계산**에 사용할 수 있다.
참조형은 들어있는 참조값을 **그대로 사용할 수 없다.**

2. 변수 대입
> **대원칙: 자바는 항상 변수의 값을 복사해서 대입한다.**
기본형은 변수에 들어있는 실제 사용하는 값을 복사해서 대입하고
참조형은 변수에 들어있는 참조값을 복사해서 대입한다.

3. 메서드 호출
메서드를 호출할 때 사용하는 매개변수(파라미터)도 결국 변수일 뿐이다.
위와 같이 기본형은 해당 값이 복사되어 전달, 참조형은 참조값이 복사되어 전달된다.

---

- 변수와 초기화
  - 멤버 변수(필드): 클래스에 선언. 변수값이 자동 초기화 된다.
  - 지역 변수: 메서드에 선언. 변수값을 직접 초기화해야한다.

- NULL, GC, NullpointerException
  - NULL: 값이 존재하지 않다는 뜻이다.
  - GC: 자바 JVM의 GC가 아무도 참조하지 않는 인스턴스를 제거해준다.
  - NullpointerException: null에 `.`을 찍었을 때 발생한다.

---

# 3. 생성자
- 생성자: 객체를 만들 때 초기값을 설정해주는 특별한 메서드이다.

> 생성자의 이름은 클래스 이름과 같아야한다.
생성자는 반환 타입이 없다.
생성자는 인스턴스를 생성하고 나서 즉시 호출 된다. ➡️ `()`을 붙여줘야한다.

```java
//생성자 등장 전
MemberInit member = new MemberInit();
member.initMember("user1", 15, 90);

//생성자 등장 후
MemberConstruct member = new MemberConstruct("user1", 15, 90);
 
```

- this: 멤버 변수와 메서드의 매개변수의 이름이 같을때 원하는 객체를 가리켜 선택할 수 있다.

---

# 4. 접근제어자
1. 필드, 메서드에 적용되는 접근제어자
```java
- private	모든 외부 호출을 막는다
- default(package-private)	같은 패키지안에서 호출은 허용한다
- protected	같은 패키지안에서 호출은 허용한다, 패키지가 달라도 상속 관계의 호출은 허용한다
- public	모든 외부 호출을 허용한다
```

2. 클래스 레벨에 적용되는 접근제어자
- 클래스 레벨의 접근제어자는 **public, default**만 사용할 수 있다.
- **public** 클래스는 반드시 파일명과 이름이 같아야 한다.
- 하나의 자바 파일에 public 클래스는 **하나만** 등장할 수 있다.

---

# 5. 자바 메모리 구조와 static
![](https://velog.velcdn.com/images/mymy/post/dbc03668-03c0-4a2d-bf92-ca969671ba77/image.png)

- **메서드 영역**: 클래스 정보를 보관한다.
- **스택 영역**: 실제 프로그램이 실행되는 영역이다. 메서드를 실행할 때마다 하나씩 쌓인다.
- **힙 영역**: 객체(인스턴스) 생성되는 영역이다. new 명령어를 사용하면 이 영역을 사용한다.

![](https://velog.velcdn.com/images/mymy/post/26af1314-3a3b-43ed-aa39-44195ba08f0f/image.png)
- **메서드 영역**: 메서드 영역은 프로그램을 실행하는 데 필요한 **공통 데이터**를 관리한다.  
  이 영역은 프로그램의 모든 영역에서 공유한다.

  - **클래스 정보**: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드 등 모든 **실행 코드**가 존재한다.
  - **static 영역**: **static 변수**들을 보관한다.
  - **런타임 상수 풀**: 프로그램을 실행하는 데 필요한 **공통 리터럴 상수**를 보관한다.  
    이 외에도 프로그램을 효율적으로 관리하기 위한 **상수들을 관리**한다.

- **스택 영역**: 자바 실행 시, 하나의 실행 스택이 생성된다.  
  각 스택 프레임은 **지역 변수**, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.

  - **스택 프레임**: 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다.  
    메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.

  - **멀티 쓰레드**: 스택 영역은 더 정확히는 각 쓰레드별로 하나의 실행 스택이 생성된다.  
    따라서 쓰레드 수만큼 스택 영역이 생성된다.

- **힙 영역**: 객체(인스턴스)와 배열이 생성되는 영역이다.  
  **가비지 컬렉션(GC)**이 이루어지는 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.  
  (힙 영역 안에서 인스턴스끼리 서로 참조하는 경우에도 GC의 대상이 된다.)

---

## 스택과 큐 자료구조

1. **스택**: 후입선출(LIFO, Last In First Out)

   ![](https://velog.velcdn.com/images/mymy/post/612b677d-871a-43e9-b89f-54661c51212a/image.png)

   - 프로그램 실행과 메서드 호출에는 스택 구조가 적합하다.
     - 자바는 스택을 사용해 메서드 호출과 지역 변수(매개 변수포함)를 관리함
     - 스택 프레임이 종료되면 지역 변수도 함께 제거된다. 스택 프레임이 모두 제거되면 프로그램도 종료함

1. **큐**: 선입선출(FIFO, First In First Out)

   ![](https://velog.velcdn.com/images/mymy/post/1b2246c9-b734-47b0-923f-b80f0956c7f5/image.png)

---

### *️⃣static 변수
- static 변수: static이 붙은 멤버변수를 정적 변수, 클래스 변수라고 부른다.
- 인스턴스와 무관하게 클래스에 바로 접근해 사용할 수 있고, 클래스 자체에 소속되어 있다. 그래서 여러 곳에서 공유하는 목적으로 사용된다.
- 자바 프로그램을 싲가할 때 딱 1개가 만들어진다.

---

## 변수와 생명주기
**1. 지역 변수(매개변수 포함)**
스택 영역에 있는 **스택 프레임**안에 보관된다.
메서드가 종료되면 스택 프레임도 제거 되는데 이때 해당 스택 프레임에 포함된 지역 변수도 함께 제거된다.
따라서 지역 변수는 **생존 주기가 짧다.**

**2. 인스턴스 변수**
인스턴스에 있는 멤버 변수를 인스턴스 변수라 한다.
**힙 영역**을 사용한다.
힙 영역은 GC(가비지 컬렉션)가 발생하기 전까지는 생존하기 때문에 보통 지역 변수보다 **생존 주기가 길다.**

**3. 클래스 변수**
메서드 영역의 **static 영역**에 보관되는 변수이다.
메서드 영역은 프로그램 전체에서 사용하는 공용 공간이다.
클래스 변수는 해당 클래스가 JVM에 로딩 되는 순간 생성된다. 그리고 JVM이 종료될때 까지 생명주기가 이어진다.
따라서 **가장 긴 생명주기를 가진다.**

> static 이 정적이라는 이유는 바로 여기에 있다.
힙 영역에 생성되는 **인스턴스 변수는 동적으로 생성되고, 제거된다.**
반면에 static 인 정적 변수는 거의 프로그램 실행 시점에 딱 만들어지고, 프로그램 종료 시점에 제거된다.

```
클래스 변수(static 변수)
생성 시점: 클래스가 메모리에 로딩될 때
소멸 시점: 프로그램 종료 시
접근 방법: 클래스명.변수명

인스턴스 변수
생성 시점: 객체 생성 시 (new)
소멸 시점: 객체가 GC(가비지 컬렉션)에 의해 제거될 때
접근 방법: 객체명.변수명

지역 변수
생성 시점: 메서드/블록 실행 시
소멸 시점: 메서드/블록 종료 시
접근 방법: 선언된 `블록 내부`에서만
```

---

### *️⃣static 메서드
- 정적 메서드(클래스 메서드)
  - 인스턴스 메서드는 인스턴스를 생성해야 호출 할 수 있는데,
  클래스 메서드는 객체 생성 없이 바로 호출 할 수 있다.
  - static 메서드는 static만 사용할 수 있다.
  즉, 정적 메서드나 정적 변수만 사용할 수 있다.
  - 클래스를 통해 접근한다.
  `DecoData.staticCall();`
  - 정적 변수, 정적 메서드를 자주 호출해야 한다면 static import 기능을 고려하자.
  
> 정적 메서드는 왜 인스턴스의 기능을 사용할 수 없을까?
정적 메서드는 클래스만 있으면 쓸 수 있어, 객체(인스턴스)를 생성하지 않기 때문에 내부에서 인스턴스 관련 정보에는 접근할 수 없다.

> main 메서드도 정적 메서드이다.
main() 메서드는 프로그램을 시작하는 시작점이 되는데, 
생각해보면 객체를 생성하지 않아도 main() 메서드가 작동했다!

---

# 6. 상속

## *️⃣final
변수에 final을 붙이면 더는 값을 변경할 수 없다.
클래스에 final을 붙이면 상속이 불가능 하다.
메서드에 final을 붙이면 오버라이딩이 불가능 하다.

> 참조형 변수에 final이 붙으면 참조 대상 자체를 다른 대상(주소)으로 변경하지 못하는 것이지,

**참조 대상의 값**은 변경할 수 있다.

---

상속을 통해 기존 클래스의 필드와 메서드를 재사용할 수 있다.
> - **부모 클래스 (슈퍼 클래스)**: 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
- **자식 클래스 (서브 클래스)**: 부모 클래스로부터 필드와 메서드를 상속받는 클래스

- 부모 클래스는 자식 클래스에 접근할 수 없다.
- 자식 클래스는 부모 클래스의 기능을 물려 받기 때문에 접근할 수 있지만, 그 반대는 아니다.


상속과 메모리 구조
- 부모의 필드와 메서드를 물려받으면서도,
    부모 클래스와 자식 클래스의 **인스턴스가 함께 생성**된다.
	내부적으로 부모와 자식의 메모리 공간이 구분되어 관리된다.
- 메서드를 호출 할 때는 **참조 변수의 타입에 따라 호출할 메서드가 결정**된다.

상속과 메서드 오버라이딩
> 메서드 오버라이딩: 부모에게서 상속받은 기능을 자식이 재정의 하는 것

- 메서드 이름, 매개변수(타입, 순서, 개수), 반환타입이 같아야 한다.
- 접근제어자: 자식은 부모의 public, protected 필드, 메서드만 접근할 수 있다.
- static, final, private 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
- 오버라이딩 된 메서드가 항상 우선권을 가진다.


- `super()`: 부모 클래스에 대한 참조
- 생성자: 상속을 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.
  - 생성자 호출 순서: 부모 -> 자식
  부모의 데이터를 먼저 초기화하고 자식의 데이터를 초기화 해야한다.

---

# 7. 다형성
- 다형성: 한 객체가 여러 타입의 객체로 취급될 수 있는 능력이다.

> 자바에서 부모 타입은 자신은 물론이고, 자신을 기준으로 모든 자식 타입을 참조할 수 있다.
이것이 바로 다양한 형태를 참조할 수 있다고 해서 **다형적 참조**라 한다.

- 캐스팅
  - 업캐스팅: 부모 타입으로 변경 (생략 가능)
  - 다운캐스팅: 자식 타입으로 변경

> `instanceof`: 어떤 인스턴스를 참조하고 있는지 확인할 때 사용

- 추상클래스: `abstract`를 사용해 추상적인 개념을 제공하는 클래스
실체인 인스턴스가 존재하지 않는다. 대신에 상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.

- 추상메서드: 부모 클래스를 상속받는 자식 클래스가 오버라이딩 해야 하는 메서드를 부모 클래스에 정의 할 수 있다.
  - 메서드 바디가 없다.
  `public abstract void sound();`
  => 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
  
- 인터페이스: 순수 추상 클래스에 편의 기능이 추가되었다.
  - 인터페이스의 메서드는 모두 **public, abstract**이다.
  - 메서드에 **public abstract 를 생략**할 수 있다. 참고로 생략이 권장된다.
  - 인터페이스는 **다중 구현(다중 상속)을 지원**한다.
  - 인터페이스에서 멤버변수는 public static final이 모두 포함되었다 간주된다.

```java
public interface InterfaceAnimal {
	public static final double MY_PI = 3.14; //이 부분이
}

public interface InterfaceAnimal {
	double MY_PI = 3.14; //이렇게 생략 가능하다
}
```

