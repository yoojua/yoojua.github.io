---
layout: post
title: "실전 자바 입문"
---

✏️인프런 <u>김영한의 자바 입문 - 코드로 시작하는 자바 첫걸음</u> 강의를 보고 한 포스팅으로 정리해봤다.
  
# Java에 대해서
![](https://velog.velcdn.com/images/mymy/post/c2e3032c-cbb7-4d49-8286-c6a24cb4eeff/image.png)

1. 자바는 표준 스펙과 구현으로 나눌 수 있다.
- 표준 스펙: 스펙은 곧 설계도이며 문서다. 이 표준 스펙을 기반으로 여러 회사에서 실제 작동하는 자바를 만든다.
자바 커뮤니티 프로세스(JCP)를 통해 관리된다.

- 구현: 여러 회사에서 자바 표준 스펙에 맞추어 실제 작동하는 자바 프로그램을 개발한다.
각각 장단점이 있다. 예를 들어 Amazon Corretto는 AWS에 최적화 되어 있다.
그리고 오라클 Open JDK를 사용하다가 Amazon Corretto 자바로 변경해도 대부분 문제 없이 동작한다.
각 회사들은 대부분 윈도우, MAC, 리눅스 같이 다양한 OS에서 작동하는 버전의 자바도 함께 제공한다.

![](https://velog.velcdn.com/images/mymy/post/f2e2517f-8a3f-43c7-80e2-4819624d7c29/image.png)

- 자바 운영 체제의 독립성: 각 환경에 맞추어 자바를 설치하는 것이 가능하다.

2. 자바 실행 과정
![](https://velog.velcdn.com/images/mymy/post/771429fd-1277-4207-9740-14b3491ee8de/image.png)

자바 프로그램은 컴파일과 실행 단계를 거친다.

1. Hello.java 와 같은 자바 소스 코드를 개발자가 작성한다.
2. 자바 컴파일러를 사용해서 소스 코드를 컴파일 한다.
- 자바가 제공하는 `javac`라는 프로그램을 사용한다.
- 컴파일 하면서 `.java` ➡️ `.class` 파일이 생성된다.
-> 📁out에 컴파일된 .class 파일이 있는 것을 확인할 수 있다.
- 자바 소스 코드를 바이트코드로 변환하며 자바 가상 머신에서 더 빠르게 실행될 수 있게 최적화하고 문법 오류도 검출한다.

3. 자바 프로그램을 실행한다.
- 자바가 제공하는 `java`라는 프로그램을 사용하고, 자바 가상 머신(`JVM`)이 실행되면서 프로그램이 작동한다.


---

# Java 문법
## 1. 변수
1. 변수란, 변할 수 있는 값(데이터)을 담을 수 있는 그릇이다.
```java
int a = 10; // 선언과 초기화를 동시에
```
숫자 정수(integer)를 보관할 수 있는 이름이 a라는 변수(데이터 저장소)를 만든다.
이렇게 변수를 만드는 것을 변수 선언이라 하고, 선언한 변수에 처음으로 값을 대입해서 저장하는 것을 변수 초기화라 한다.

- 변수를 초기화 하지 않는다면?
초기화를 하지않으면 이상한 값이 출력될 수 있다. 그래서 자바는 변수를 초기화 하도록 강제한다.

- 변수 타입

```java
<정수>
int , long : 자바는 정수에 기본으로 int 를 사용한다. 만약 20억이 넘을 것 같으면 long 을 쓴다.
파일을 다룰 때는 byte 를 사용한다.

<실수>
double : 실수는 고민하지 말고 double 을 쓰면 된다.

<불린형>
boolean : true , false 참 거짓을 표현한다. 이후 조건문에서 자주 사용된다.

<문자열>
String : 문자를 다룰 때는 문자 하나든 문자열이든 모두 String 을 사용하는 것이 편리하다.
```

```java
byte : 표현 길이가 너무 작다. 또 자바는 기본으로 4byte( int )를 효율적으로 계산하도록 
설계되어 있다. int를 사용하자.
byte 타입을 직접 선언하고 여기에 숫자 값을 대입해서 계산하는 일은 거의 없다.
대신에 파일을 바이트 단위로 다루기 때문에 파일 전송, 파일 복사 등에 주로 사용된다.

short : 표현 길이가 너무 작다. 또 자바는 기본으로 4byte( int )를 효율적으로 계산하도록
설계되어 있다. int 를 사용하자

float : 표현 길이와 정밀도가 낮다. 실수형은 double 을 사용하자.
float는 숫자 뒤에 f를 붙여줘야한다.
float 5 = 10.0f;

char : 문자 하나를 표현하는 일은 거의 없다. 문자 하나를 표현할 때도 문자열을 사용할 수 있다.
	   예를 들어 String a = "b" 와 같이 사용하면 된다.
```
- 변수 명명 규칙
클래스는 대문자로 시작하고, 나머지는 낙타표기법을 사용한다.
상수는 모두 대문자를 사용하고 언더바로 구분한다.
패키지는 모두 소문자를 사용한다.

---
## 2. 연산자
- 종류
```
산술 연산자: + , - , * , / , %
증감(증가 및 감소) 연산자: ++ , --
비교 연산자: == , != , > , < , >= , <=
논리 연산자: && (AND), || (OR), ! (NOT)
대입 연산자: = , += , -= , *= , /= , %=
삼항 연산자: ? :
```
- 우선순위
```
1. 괄호 ()
2. 단항 연산자 (예: ++ , -- , ! , ~ , new , (type) )
3. 산술 연산자 ( * , / , % 우선, 그 다음에 + , - )
4. Shift 연산자 ( << , >> , >>> )
5. 비교 연산자 ( < , <= , > , >= , instanceof )
6. 등식 연산자 ( == , != )
7. 비트 연산자 ( & , ^ , | )
8. 논리 연산자 ( && , || )
9. 삼항 연산자 ( ? : )
10. 대입 연산자 ( = , += , -= , *= , /= , %= 등등)
```
---
## 3. 조건문과 반복문
- 조건문: 특정 조건에 따라 다른 코드를 실행하는 것
if문과 switch문이 있다.
- 반복문: 특정 코드를 반복해 실행하는 것
while, do-while, for문이 있다.

> 정해진 횟수만큼 반복을 수행해야 하면 for문을 사용하고
그렇지 않으면 while문을 사용하면 된다.

---
## 4. 스코프와 형변환
- 스코프(scope): 변수의 접근 가능한 범위

>변수는 선언한 위치에 따라 **지역 변수, 멤버변수**(클래스 변수, 인스턴스 변수)와 같이 분류된다.
지역 변수는 이름 그대로 특정 지역에서만 사용할 수 있는 변수다. 
그 특정 지역을 벗어나면 사용할 수 없다.

아래 예시를 보자.

```java
public class While {
    public static void main(String[] args) {
    int sum = 0;
	int i = 1;
	int endNum = 3;
 
while (i <= endNum) {
	sum = sum + i;
	System.out.println("i=" + i + " sum=" + sum);
	i++;
		}
	}
}
```
```java
public class For {
	public static void main(String[] args) {
	int sum = 0;
	int endNum = 3;
 
for (int i = 1; i <= endNum; i++) {
	sum = sum + i;
	System.out.println("i=" + i + " sum=" + sum);
		}
	}
}
```
- while문 vs for문 - 스코프 관점
while문의 경우 변수 i의 스코프가 main() 메서드 전체가 된다.
반면에 for문의 경우 변수 i 의 스코프가 for문 안으로 한정된다.
❗따라서 변수 i와 같이 for 문 안에서만 사용되는 **카운터 변수**가 있다면, while문 보다는 **for문을 사용해서 스코프의 범위를 제한하는 것이 메모리 사용과 유지보수 관점에서 더 좋다.**

---
- 형변환
자동 형변환(묵시적 형변환)
명시적 형변환: 큰 범위에서 작은 범위 대입

- 오버플로우
형변환을 할 때 작은 숫자가 표현할 수 있는 범위를 넘어서면 전혀 다른 숫자가 표현되는데 이 현상을 오버플로우라고 한다.
> 오버플로우가 발생했을 때 로직을 고치는데 시간을 쓰지말고, 타입을 변경해서 막아야한다.

---
## 5. 배열과 메서드
- 배열: 같은 타입의 변수를 하나로 묶어둔 것이다.
변수처럼 초기화를 해줘야한다.
  - index: 배열의 위치. 0부터 시작해 (n-1)로 끝난다.
  - 숫자는 0, boolean은 false, String은 null로 초기화 된다.
  
![](https://velog.velcdn.com/images/mymy/post/3b714c50-65e1-4f21-95be-3885cd4d698b/image.png)
```java
int[] students; // 1. 배열 변수 선언
students = new int[5];

// 2. 변수 값 대입
students[0] = 90;
students[1] = 80;
students[2] = 70;
students[3] = 60;
students[4] = 50;
```
1. 배열을 생성하면 배열의 크기만큼 메모리를 확보한다. (4byte * 5 = 20byte)
2. 이 배열에 접근할 수 있는 참조값(주소)을 반환한다.

```java
int[] students = new int[5]; // 1. 배열 생성
int[] students = x001;       // 2. new int[5]의 결과로 x001 참조값 반환
students = x001             //  3. 최종 결과
```

![](https://velog.velcdn.com/images/mymy/post/ee97f022-425c-41dc-8f3f-3e01209737e7/image.png)
- 2차원 배열: 행(row)과 열(column)으로 구성된다.
먼저 행 번호를 찾고 열 번호를 찾으면 된다.

```java
int [][] arr = new int[2][3]; //행2, 열3

arr[0][0] = 1;
arr[0][1] = 2;
arr[0][2] = 3;
arr[1][0] = 4;
arr[1][1] = 5;
arr[1][2] = 6;

------------------

int [][] arr = new int[][]{
	{1,2,3},
    {4,5,6}
 };
 
------------------

int [][] arr = {
	{1,2,3},
    {4,5,6}
 };
```
---
## 6. 메서드
- 메서드: 재사용 가능한 함수의 모음
함수에 값을 입력하면, 어떤 연산은 처리한 다음에 결과를 반환한다.

- 메서드 선언
  ```public static int add(int a, int b)```
 메서드 이름, 반환 타입, 매개변수(파라미터) 목록을 포함한다.
메서드 선언 정보를 통해 다른 곳에서 해당 메서드를 호출할 수 있다.
메서드 선언에 사용되는 변수는 영어로 파라미터(parameter), 한글로 매개변수라 한다.

- 메서드 본문
  메서드가 수행해야 하는 코드 블록이다.
  return을 만나면 해당 메서드는 종료된다.

> **용어 정리**
 인수(인자, 아규먼트): 전달하는 값
 매개변수(파라미터): 메서드를 정의할 때 선언한 변수
 
 > 즉, 실제로 함수가 호출 될 때 넘기는 변수값이 인수.
 함수를 정의할 때 사용되는 변수가 매개변수.
 ▶️ 메서드를 호출할 때 인수를 넘기면, 그 인수가 매개변수에 대입된다.

---
- 메서드 정의
```java
public static int add(int a, int b) {
	//메서드 본문, 실행 코드
}
```

```java
제어자 반환타입 메서드이름(매개변수 목록) {
	메서드 본문
}
```
- 메서드 오버로딩: 메서드 명이 같고 매개변수가 다른 메서드를 여러 개 정의 하는 것
- 메서드 오버라이딩: 부모 클래스(상위 클래스)에서 정의된 메소드를 하위 클래스에서 새로운 구현으로 대체하는 과정
