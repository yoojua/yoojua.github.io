---
layout: post
title: "실전 자바 중급 1편"
---

# 섹션1. Object 클래스
자바에서 모든 클래스의 최상위 부모 클래스는 Object 클래스이다. 사실 자바가 extends Object 코드를 넣어주어서 여태 생략 가능했던 것이다.
그래서 모든

- **동일성과 동등성**
동일성(Identity): `==연산자`를 사용해 두 객체의 참조가 동일한 객체인지 확인
동등성(Equality): `equals()`를 사용하여 두 객체가 논리적으로 동등한지 확인
>실무에서는 equals()와 hashCode()는 보통 함께 사용한다.

---

# 섹션2. 불변객체
불변객체(Immutable Object): 객체의 상태(객체 내부의 값, 필드, 멤버 변수)가 변하지 않는 객체

- **기본형**: 하나의 값을 여러 변수에서 절대로 공유하지 않는다.
- **참조형**: 하나의 객체를 참조값을 통해 여러 변수에서 **공유**할 수 있다.

**참조형**의 경우, 여러 변수가 하나의 객체를 공유하면, 한 변수에서 객체를 변경할 때 다른 변수에도 영향을 미쳐 사이드 이펙트가 발생할 수 있다.
이때, 필드 값을 변경할 수 없게 클래스를 설계하면 된다.

> 1. 모든 필드를 **final**로 선언해서 초기화 후 값이 변경되지 않도록 한다. (사실 없이도 가능함)
2. 변경 가능한 **객체를 참조하지 않는다.**
3. setter 메서드를 제공하지 않는다.
값 변경이 불가능하도록 **getter만 제공**한다.


- 불변 객체를 사용하지만 값을 변경해야 한다면
➡️ 새로운 객체를 만들어서 반환하자. 변수명은 `with`으로 시작하는 것이 관행이다.

---

# 섹션3. String 클래스
String은 불변 객체이다. 그래서 생성 이후에 내부의 문자열 값을 절대 변경할 수 없다.
값을 변경하고 싶을때 String Builder를 사용하면 된다.

1.  `StringBuilder`
가변 String을 지원한다.
  - **사이드 이펙트**에 주의해야한다.
  문자열 변경 후엔 String으로 변환해 사용하는 것이 안전하다.
  - **메서드 체이닝 기법**을 제공한다.

>- **append**: 기존 문자열에 새로운 문자열을 추가한다.
String과 달리, 새로운 객체를 생성하지 않고 기존 객체를 수정한다.
- **insert**: 특정 위치에 문자열을 삽입한다.
- **delete**: 특정 위치의 문자열을 삭제한다.
- **reverse**: 문자열을 뒤집는다.

2. String 최적화
자바 컴파일러는 **문자열 리터럴**을 더하는 부분을 **자동**으로 합쳐준다.
따라서 런타임에 별도의 문자열 결합 연산을 수행하지 않기 때문에 성능이 향상된다.

```java
//컴파일 전
String helloWorld = "Hello, " + "World!";

//컴파일 후
String helloWorld = "Hello, World!";
```

이처럼 간단한 경우에는 StringBuilder를 사용하지 않고 `+`을 사용하면 충분하다.

- 문자열을 루프안에서 문자열을 더하는 경우에는 최적화가 이루어지지 않기에, StringBuilder를 사용한다.

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 100000; i++) {
		sb.append("Hello Java ");
 }
 ```

3. 참고
StringBuilder와 똑같은 기능을 수행하는 **StringBuffer** 클래스도 있다.
- **StringBuilder**: **멀티 스레드**에 상황에 안전하지 않지만 동기화 오버헤드가 없으므로 **속도**가 빠르다.
- **StringBuffer**: 내부에 동기화가 되어 있어서, **멀티 스레드** 상황에 안전하지만 동기화 오버헤드로 인해 **성능**이 느리다.

---

# 섹션 4. 래퍼 클래스
자바는 객체 지향 언어이다.
그런데 자바 안에서 객체가 아닌 것이 있다. 바로 기본형이다.
그래서 **기본형을 객체로 다루기 위해 래퍼 클래스를 사용한다.**

1. 래퍼 클래스
메서드를 제공할 수 있고, NULL 값을 가질 수 있다.
`equals`

```java
byte → Byte
short → Short
int → Integer
long → Long
float → Float
double → Double
char → Character
boolean → Boolean
```

2. 박싱 & 언박싱
a. 래퍼 클래스 생성(박싱, Boxing)
기본형 → 래퍼 클래스로 변환
`new Integer(10)` </br>
b. 언박싱(Unboxing)
래퍼클래스 → 기본형으로 변환
`int Value`
➡️ 이 과정이 번거롭기에 자바에서 오토 박싱 & 언박싱을 지원한다. (컴파일러가 알아서 바꿔준다.)

```java
public class BoxingUnboxingExample {
    public static void main(String[] args) {
        // 박싱: 기본형 int를 Integer 객체로 변환
        Integer boxedInteger = Integer.valueOf(10);
        System.out.println("박싱된 Integer: " + boxedInteger);

        // 언박싱: Integer 객체를 기본형 int로 변환
        int unboxedInt = boxedInteger.intValue();
        System.out.println("언박싱된 int: " + unboxedInt);
    }
}
```
3. 기본형
그럼에도 기본형이 존재하는 이유는 연산이 빠르기 때문이다.

---

# 섹션 5. 열거형(ENUM)
열거형은 예상 가능한 값들의 집합을 표현하는 데 사용된다. 
- 특정 값의 **범위를 제한**하고 **타입 안정성**을 확보하기 위해서 생겼다.

```java
public enum Grade {
	BASIC, GOLD, DIAMOND
}
```
- 열거형은 자동으로 java.lang.Enum을 상속 받기에 다른 클래스를 **상속** 받을 수 없다.
- 열거형은 **인터페이스**를 구현할 수 있다.
- 열거형에 **추상 메서드**를 선언하고 구현할 수 있다. (익명 클래스와 같은 방식을 사용한다.)
- 열거형을 사용하는 경우 `static import`를 적절하게 사용하면 더 읽기 좋은 코드를 만들 수 있다.

</br>

- 주요메서드
```java
values(): 모든 ENUM 상수를 포함하는 배열을 반환한다.
valueOf(String name): 주어진 이름과 일치하는 ENUM 상수를 반환한다.
name(): ENUM 상수의 이름을 문자열로 반환한다.
toString(): ENUM 상수의 이름을 문자열로 반환한다.
name() 메서드와 유사하지만, toString() 은 직접 오버라이드 할 수 있다.
```

---
# 섹션 6. 날짜와 시간
1. 모든 날짜 클래스는 **불변**이다. 
따라서 변경이 발생하는 경우 새로운 객체를 생성해 반환하므로 반환값을 꼭 받아야한다.

2. 날짜와 시간
날짜와 시간을 계산하는 것은 매우 어렵고 복잡하다.
- **날짜의 경우, 윤년과 각 달의 일수** 등을 고려해야 하고 뺄셈 연산으로 정확한 결과를 얻기 어렵다.
- **시간**의 경우, 세계는 다양한 **타임존**으로 나뉘어 있는데, 각 타임존은 **UTC(협정 세계시)로부터의 시간 차이로 정의**된다.
타임존 간의 날짜와 시간 변환을 정확히 계산하는 것은 복잡하다.
> 타임존
> 1. GMT (그리니치 평균시)
> 2. UTC (협정 세계시)
역사적으로 GMT가 국제적인 시간 표준으로 사용되었고, UTC가 나중에 이를 대체하기 위해 도입되었다.
UTC가 GMT보다 더 정밀한 시간 측정을 하고 국제적인 표준이다.
- **써머타임**도 국가마다 고려해야한다. (Daylight Saving Time, DST)

---

# 섹션 7. 중첩 • 내부클래스
![](https://velog.velcdn.com/images/mymy/post/5c9b6c8e-b410-4c35-8ae5-9d7b950545a0/image.png)

>1. **중첩 클래스**: 클래스 안에 클래스를 중첩하는 것
2. **내부 클래스**: 내부 클래스, 지역 클래스, 익명 클래스를 포함해서 말함


여기서 **중첩**이란 어떤 다른 것이 내부에 위치하거나 포함되는 구조적인 관계.
**내부**란 나의 내부에 있는 나를 구성하는 요소이다.

</br>

중첩 클래스는 총 4가지가 있고, 크게 2가지로 분류할 수 있다.

> **정적 중첩 클래스**
- static이 붙는다.
- 바깥 클래스의 인스턴스에 소속되지 않는다.
- 바깥 클래스와 독립적인 별개의 클래스처럼 동작한다.

➡️다른 클래스를 그냥 중첩해 둔 것!
자신이 속한 바깥 클래스와 연관이 있는 기능을 묶어 한 곳에 관리하기 위해 사용된다.

> **내부 클래스 종류**
- static이 붙지 않는다.
- 바깥 클래스의 인스턴스에 소속된다.
- 바깥 클래스의 구성 요소로 동작한다.
  - 내부 클래스: 바깥 클래스의 멤버로 선언된 클래스
  - 지역 클래스: 메서드 내부에서 선언된 클래스
  - 익명 클래스: 이름 없이 일회성으로 사용하는 클래스
  
➡️내부 클래스는 바깥 클래스의 인스턴스에 소속된다.


3. 지역 클래스
- 지역 클래스도 내부 클래스이므로 바깥 클래스의 **인스턴스 멤버에 접근**할 수 있다. **(지역 변수에 접근할 수 있다.)**
- 지역 변수와 같이 코드 블럭 안에서 정의된다.
- 지역 클래스가 접근하는 지역 변수의 값은 변경하면 안된다.

3-1. 지역 변수 캡쳐
- **지역 클래스는 지역 변수에 접근할 수 있다.**

지역 변수의 생명주기는 짧고, 지역 클래스를 통해 생성한 인스턴스의 생명 주기는 길다.
지역 클래스를 통해 생성한 인스턴스가 지역 변수에 접근해야 하는데, 둘의 생명 주기가 다르기 때문에 인스턴스는 살아있지만, 지역 변수는 이미 제거된 상태일 수 있다.
    
- 자바는 이런 문제를 해결하기 위해 지역 클래스의 인스턴스를 생성하는 시점에 필요한 **지역 변수를 복사하여 생성한 인스턴스**에 함께 넣어 둔다. (변수 캡쳐)

>🚩실제로는 지역 변수에 접근하는 것이 아니라 **인스턴스에 있는 캡처한 캡처 변수에 접근**한다.

4. 익명 클래스
익명 클래스는 지역 클래스인데, 클래스의 이름이 없다는 특징이 있다.

- 클래스를 별도로 정의하지 않고도 인터페이스나 추상 클래스를 즉석에서 구현할 수 있어 코드가 더 간결해진다.
- 익명 클래스는 **단 한 번만 인스턴스를 생성** 할 수 있다.
- **익명 클래스**는 클래스의 **본문(body)을 정의하면서 동시에 생성**한다.
new 다음에 바로 상속 받으면서 구현 할 부모 타입을 입력하면 된다.
- 익명 클래스는 부모 클래스를 상속 받거나, 또는 **인터페이스**를 구현해야 한다.
익명 클래스를 사용할 때는 상위 클래스나 인터페이스가 필요하다.
- 익명 클래스는 말 그대로 이름을 가지지 않으므로, **생성자를 가질 수 없다. (기본 생성자만 사용됨)**
- `AnonymousOuter$1` 과 같이 자바 내부에서 바깥 클래스 이름 + $ + 숫자로 정의된다.
익명 클래스가 여러개면 $1 , $2 , $3 으로 숫자가 증가하면서 구분된다.

# 섹션 8. 예외처리
> 예외처리 결론: 현대 애플리케이션 개발에서는 체크예외를 거의 쓰지 않는다.

![](https://velog.velcdn.com/images/mymy/post/896aa7db-d3cc-4853-868f-f1db00c70faa/image.png)

1. 예외 개념
- Object는 모든 객체의 최상위 부모이다.
- Throwable은 최상위 예외.
- Error: 애플리케이션에서 복구가 불가능한 시스템 예외이다. (메모리 부족, 심각한 시스템 오류)
- Exception: 체크 예외.
  - 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외.
  - Exception과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다.
  단, RuntimeException은 예외로한다.
- RuntimeException: 언체크예외, 런타임 예외
  - 언체크예외: 컴파일러가 체크하지 않는다.
  
> - 언체크 예외는 개발자가 발생한 예외를 명시적으로 처리하지 않아도 된다.
- 예외도 상속 개념이 적용되어 상위 예외를 잡으면 하위 예외까지 함께 잡는다.
그래서 Throwable 예외를 잡으면 Error 예외도 함께 잡을 수 있기에 잡으면 안된다.


![](https://velog.velcdn.com/images/mymy/post/06031f87-7762-4f34-bdb8-d61b12ef7f23/image.png)
2. 예외 기본 규칙
> 1. 예외는 잡아서 처리하거나 밖으로 던저야한다.
> 2. 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리할 수 있다.
  - 예를 들어서 Exception 을 `catch`로 잡으면 그 하위 예외들도 모두 잡을 수 있다.
  - 예를 들어서 Exception 을 `throws`로 던지면 그 하위 예외들도 모두 던질 수 있다.
> 3. 예외도 객체이다.

3. 체크 예외
체크 예외: 잡아서 처리하거나 밖으로 던지도록 선언해야한다. 그렇지 않으면 컴파일 오류 발생.
- Exception을 상속받은 예외는 체크 예외가 된다.
- throw 예외: 새로운 예외를 발생시킨다.
- throws 예외: 발생시킨 새로운 예외를 밖으로 던진다.

```java
// 문제 상황
throw new Exception("ex");

// 예외 잡아서 처리하는 코드
try {
	client.call();
	} catch (Exception e) {
	// 예외 처리 로직
	System.out.println("예외처리, message=" + e.getMessage());
	}
	System.out.println("정상 흐름");

// 예외를 밖으로 던지는 코드
// 체크 예외는 예외를 잡지 않고 밖으로 던지려면 throws 예외를 메서드에 필수로 선언해야 한다.
public void catchThrow() throws Exception {
	client.call();
	}
```

- 예외를 잡아서 처리하려면 `try ~ catch(..)` 를 사용해서 예외를 잡으면 된다.
    - try 코드 블럭에서 발생하는 예외를 잡아서 catch로 넘긴다.
    - 만약 try에서 잡은 예외가 catch의 대상에 없으면 예외를 잡을 수 없다. 이때는 예외를 밖으로 던져야한다.
        
- 예외가 main() 밖으로 던져지면 예외 정보와 `스택 트레이스(Stack Trace)`를 출력하고 프로그램이 종료된다.
스택 트레이스 정보를 활용하면 예외가 어디서 발생했는지, 어떤 경로를 거쳐서 넘어왔는지 확인할 수 있다.
    
- 장단점
개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전 장치이다.
개발자는 어떤 체크 예외가 발생하는지 쉽게 파악할 수 있다.
하지만 실제로는 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에,번거롭다. 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 한다

4. 언체크 예외
언체크 예외: RuntimeException과 그 하위 예외
- 체크 예외와의 차이점
  - 체크 예외: 예외를 잡아서 처리하지 않으면 항상 throws를 사용해서 던지는 예외를 선언해야함
  - 언체크 예외: 예외를 잡아서 처리하지 않아도 throws를 생략할 수 있음

```java
// 문제 상황
 throw new MyException("ex");

// RuntimeException을 상속받은 예외는 언체크 예외가 된다.
public class MyException extends RuntimeException {
	public MyException(String message) {
		super(message);
		}
}
```

```java
// 예외 잡아서 처리하는 코드
try {
	client.call();
	} catch (MyException e) {
	// 예외 처리 로직
		System.out.println("예외처리, message=" + e.getMessage());
	}
	System.out.println("정상 흐름");

// 예외를 잡지 않아도 된다.
public void callThrow() {
 client.call();
 }
}
```

- 장단점
신경쓰고 싶지 않은 예외를 무시할 수 있고, throws를 생략할 수 있다.
하지만 언체크 예외는 개발자가 실수로 예외를 누락할 수 있다.

5. 예외처리 실습
   
```java
try {
 //정상 흐름
} catch {
 //예외 흐름
} finally {
 //반드시 호출해야 하는 마무리 흐름
}
```
1. 예외를 계층화해서 다양하게 만들면 더 세밀하게 예외를 처리할 수 있다.
   더 디테일한 자식 예외을 먼저 잡아야 한다.
2. `|`를 사용해 여러 예외를 한 번에 잡을 수 있다.
3. 처리할 수 없는 예외(시스템 오류)는 고객에게 메시지를 보여주고,
   공통적으로 처리할 수 있는 곳에서 해결// 예외 잡아서 처리하는 코드
try {
	client.call();
	} catch (Exception e) {
	// 예외 처리 로직
	System.out.println("예외처리, message=" + e.getMessage());
	}
	System.out.println("정상 흐름");

// 예외를 밖으로 던지는 코드
// 체크 예외는 예외를 잡지 않고 밖으로 던지려면 throws 예외를 메서드에 필수로 선언해야 한다.
public void catchThrow() throws Exception {
	client.call();
	}
```

- 예외를 잡아서 처리하려면 `try ~ catch(..)` 를 사용해서 예외를 잡으면 된다.
    - try 코드 블럭에서 발생하는 예외를 잡아서 catch로 넘긴다.
    - 만약 try에서 잡은 예외가 catch의 대상에 없으면 예외를 잡을 수 없다. 이때는 예외를 밖으로 던져야한다.
        
- 예외가 main() 밖으로 던져지면 예외 정보와 `스택 트레이스(Stack Trace)`를 출력하고 프로그램이 종료된다.
스택 트레이스 정보를 활용하면 예외가 어디서 발생했는지, 어떤 경로를 거쳐서 넘어왔는지 확인할 수 있다.
    
- 장단점
개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전 장치이다.
개발자는 어떤 체크 예외가 발생하는지 쉽게 파악할 수 있다.
하지만 실제로는 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에,번거롭다. 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 한다

# 4. 언체크 예외
언체크 예외: RuntimeException과 그 하위 예외
- 체크 예외와의 차이점
  - 체크 예외: 예외를 잡아서 처리하지 않으면 항상 throws를 사용해서 던지는 예외를 선언해야함
  - 언체크 예외: 예외를 잡아서 처리하지 않아도 throws를 생략할 수 있음

```java
// 문제 상황
 throw new MyException("ex");

// RuntimeException을 상속받은 예외는 언체크 예외가 된다.
public class MyException extends RuntimeException {
	public MyException(String message) {
		super(message);
		}
}
```

```java
// 예외 잡아서 처리하는 코드
try {
	client.call();
	} catch (MyException e) {
	// 예외 처리 로직
		System.out.println("예외처리, message=" + e.getMessage());
	}
	System.out.println("정상 흐름");

// 예외를 잡지 않아도 된다.
public void callThrow() {
 client.call();
 }
}
```

- 장단점
신경쓰고 싶지 않은 예외를 무시할 수 있고, throws를 생략할 수 있다.
하지만 언체크 예외는 개발자가 실수로 예외를 누락할 수 있다.

5. 예외처리 실습
   
```java
try {
 //정상 흐름
} catch {
 //예외 흐름
} finally {
 //반드시 호출해야 하는 마무리 흐름
}
```
1. 예외를 계층화해서 다양하게 만들면 더 세밀하게 예외를 처리할 수 있다.
   더 디테일한 자식 예외을 먼저 잡아야 한다.
2. `|`를 사용해 여러 예외를 한 번에 잡을 수 있다.
3. 처리할 수 없는 예외(시스템 오류)는 고객에게 메시지를 보여주고,
   공통적으로 처리할 수 있는 곳에서 해결하자.
   또한, 오류에 대한 로그를 남겨두자.
4. try-with-resources

```java
try (Resource resource = new Resource()) {
 // 리소스를 사용하는 코드
}
```

try에서 외부 자원을 사용하고, try가 끝나면 외부 자원을 반납하는 패턴을 반복한다.

5. 실무에서는 Slf4J, logback 같은 별도의 로그 라이브러리를 사용해 콘솔과 특정 파일에 함께 결과를 출력한다.
   공부 단계에서는 e.printStackTrace()를 사용하자
